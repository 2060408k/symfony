# Collection Delete Orphan Removal

 This genus has four genus scientists and we can update those genus scientists but we can't add new ones and we can't delete scientists from those genus. That's what we need to work on now. Let's start with deleting them. Let's start with the UI for this because what I want to be able to do is just click a little x icon and then when we hit save, it will actually delete that genus scientist from the database. Inside of your form ... I'll add a new class to the column: js-genus-scientist-item that we'll use in JavaScript in a second. Below that, we'll add a little link with it's own js-remove-scientist class and a little x icon inside. Perfect.

 Now, to hook this up with JavaScript, I'm not going to put the JavaScript in this template because this template is actually included from both edit and at new.html.twig. We actually need to put the JavaScript in this top level template. For now we're going to ignore the new template and just put the JavaScript straight into edit.html.twig by overriding the blocked JavaScripts, calling the parent function to include the JavaScript that's in our base layout ... Then I'm just going to make a simple document.ready block and inside ...

 Back in form, before we write more JavaScript, add one more class to the row that's around the entire thing called js-genus-scientist-wrapper. That's going to allow us to add and remove elements inside of there. Then back in edit, say [inaudible 00:03:10] wrapper equals, then use jQuery to select that element, then we'll attach a listener on that. On click of .js-genus, js-removescientist, which is the class that we have on the anchor tag so when that anchor is clicked ... Then we'll, of course, say e.preventdefault and then just for now, just to get the user interface working, we'll say this.closest.js-genusscientistitem.

 We'll take the anchor length and go up until it finds the Li tag that is the div that is around everything. Then we'll say .fadeout.remove. Cool. It's just that. If we refresh, we're going to x, and it goes away. Obviously this is only talking about the user interface at this point. If we submit, we actually get a strange error. It says,  Update genus scientist set year studied equals null and null  so our server is not expecting any of these genus scientists to disappear. By hitting x here, it actually submits that sub form blank and Symphony thinks that we're trying to set that genus scientist to null. What we want to do is actually delete that genus scientist from the database.

 How can we do that? Well, a couple of steps. First, in genus form type, under the genus scientist field, add a new flag called allow delete, set to true. This tells the collection type, which holds an array of submitted genus scientists, that it's okay if one of those genus scientists is actually not resubmitted. In fact, it's okay if we delete one and when we do delete one, we don't want to set that genus scientists data to null, we actually want to remove it from the array. With this, when we delete a genus scientist and submit, the final array will have three genus scientists in it, instead of four.

 If we try it out now it doesn't give us an error, but it still doesn't work. The question is: why? Well let's think about this. When we submit after deleting one of the genus scientists, the form component sets the remaining three genus scientist objects onto the genus scientist's property of the genus object. Then we save the genus. The problem is that this is now the inverse side of the relationship, meaning if we remove or add a genus scientist from this array, it doesn't make any difference. Doctrine doesn't delete or add those because this is the inverse side of the relationship.

 The way we fix that is actually the same way that we fixed this problem earlier when we were dealing with the many to many relationship with user. It's a two step process. First, in genus form type, we're also going to set by reference to false. I remind you, with collections like this, by default the form component doesn't call set genus scientists. In fact, there is no set genus scientists method in our genus. It simply calls get genus scientists and then modifies that array collection by reference. We don't want that to happen now. By setting it to false, it's going to give us the flexibility we need to set the inverse side of the relationship.

 Just like we did before with the user object, if we submit right now, you notice we get an error. If you scroll down the error is being caused when it calls remove genus scientist. As soon as we set that by reference to false in the form type, it means that it's actually going to take advantage of the add genus scientist and the remove genus scientist methods in our genus. If we delete a genus scientist from the form, it calls remove genus scientist. That's perfect, it's just that these methods are totally outdated back before we created the genus scientist entity. We just need to update them. Genus scientist and then change user to genus scientist.

 For the last line, it will actually be genus scientist set genus and we'll actually set it to null. I'm going to update the note to say the opposite. Needed to update the owning side of the relationship. Now when we submit the form after removing one of our genus scientists, it should actually remove it from this array but also take that genus scientist and set its genus to null. That doesn't mean we're quite done because if you save now, you'll notice you get a similar error as before: update genus scientist set genus ID to null, which makes perfect sense. We have a genus scientist entity and right now, we're setting its genus to null, so that's how it updates.

 That's not what we want, right? We want to say,  No no. If the genus scientist is no longer set on this genus, it should be deleted entirely from the database . Fortunately, if that's what you need, it's very easy to set that up. In genus, find your genus scientist property. I'm going to move the one to many onto multiple lines so we can read it. Then we're going to add orphan removal equals true, and that's it. It says that if any of these genus scientists suddenly have their genus set to null, or actually even if their genus is changed to a different genus, just delete them entirely.

 Let's go back. I'll refresh the form to make sure it's fresh. We have four genus scientists, delete one, we hit save, and now we only have three. That fourth genus scientist was just deleted from the database. This has got a lot of complexity to it, but in the end you just need to make sure that you have allow delete true by reference false, that you have your nice remove genus scientist method that sets the mapping side, and that you also have orphan removal equals true so it finally deletes those extra ones. Delete, check. Next thing we need to do is allow us to add new genus scientists to this genus.
 
