# Authorization Roles

Up until now, everything has been about authentication. Building our system so that we can identify which user is logging in. We've done that with our cool login form authenticator. I hope that you can see that you can make these authenticators do whatever you want, and you could even create multiple authenticators. That's something that we'll do with social authentication in a future screencast. We also created a really cool JSON web token authenticator in our Symfony REST series, so you can check that out.

Now I want to turn to authorization which is all about figuring out whether or not the user has access to do something. For example, right now we have an admin section, which probably not everyone should have access to. There's a number of different ways to deny access, and the easiest one is right inside security.yml, it's called access control. Go in 4 spaces, so this is on the same level as firewalls, not below it. Add access control. Go out 4 spaces- { and then you're going to do a regular expression path: so ^/Admin meaning anything starting with /admin we're going to require role_user.}

Let's just try that out first. I'm going to log out, go to /admin/genus and there it goes. It bounces to the Login page and I can log in, and it bounces me back to this page and I do have access because my user has role user. If you hover down on the web developer tool bar, and click, you will see roles, role user. That's awesome. Remember, that's happening because in our user class, we're just hard coding right now and saying every single user in the system gets a single role called role user.

At first, that's as complex as Symfony's authorization system goes. Give users roles, and then you check and see if they have those roles. The second will make the roles dynamic, so that different users can have different roles. This access control is really interesting down here because you can have many access controls. You can create another line below this and secure a different section of your site, like ^/checkout requires some different roles. The key thing to know is that these access controls and match like routing. They match from top to bottom, and you only ever match one access control at a time. It will match the first one that it finds from top to bottom. This means you can do some cool stuff with access control. If you have a site where pretty much every page is secured, but then only a few of them are open, you can actually use access controls to lock down every page and then white list the few pages that shouldn't be authenticated.

If we change this to role admin, which the role I don't have, go back and refresh. Now we get the access denied page. A few important things here. First, roles can be anything. I don't have to preregister this role, admin. I just made that up on the spot. My user doesn't have that, so I'm denied access. The only rule about roles is that they must start with role_ . There's a reason for that I'll mention later. Second, notice this shows the access denied screen, 403, forbidden. Obviously this is not what your user is going to see, but you have he opportunity to customize your error pages to customize them on a status by status code basis. You can have a different 403 error page than 404 error page.

The great thing about access control is it's just really simple to secure entire areas of your site. However, it's not very flexible . I do use access controls to lock down big sections of my site, but I also really handle my authorization inside of my controller, where I can find greater controls. I'm gong to comment about this access control, and I'm going to show you how to do it in your controller. Go to genus admin controller. For all the complexity of the security system, everything you're going to do for the security is just two services. If you want to check whether or not the user has access, it's as simple as this. If not this error, get, we're gong to be at series called Security.authorizationchecker. It has exactly one method on it which is called, is granted. We'll pass it, role_admin. If we do not have this role, then we're going to throw this arrow, create access denied exception. You can give it any message there. That's only going to be shown to us developers.

If you go back now and refresh this page, there it is. A couple of key things here. The security authorization checker is the way you check security. If you need to check security outside of the controller in the future, now you know how to do it. The second thing is, this great access denied exception if I hold command and click into it, it just literally throws a class called access denied exception. If you ever needed the denied access anywhere in your system, you can just throw that exception and it simply will take care of everything else. You don't need to worry about whether or not the user is logged in or not. If the user is not logged in, it will redirect them to the login page instead of showing them that 403 page.

In reality, you won't type those 3 lines because you're going to be lazy and you just type deny access unless granted role_admin and that does the exact same thing. Or if you like annotations, you can get a little fancier than this. Up above your controller, you can say at security and then you can type in an expression. Is_granted is one of the most important functions you have inside of expression. Role_at admin. That will work the exact same way. You just re-message name changes here.

Of course the problem here is that we really want our entire controller locked down, and right now we can still go to /admin and /genus/new so we need to repeat this annotation or that line in the controller on every single controller inside of here. You now the situation. Direct what I'm doing. If you like the annotations is just putting above your class. As soon as you do that, it locks down everything inside of that controller.

This is great, but we still have a user class which just still has a single, hard coded role in it. If you're security system is that simple, that's fine. Just make sure your user has at least one role at all times, but other than that, it doesn't matter. Let's say in our system we're going to give different users different roles. How do we do that? Very simple. Just create a private roles property. We're going to persist this to doctrines, give it @RM/com and we're going to have a JSON ready type. It's going to allow us to actually store an array on this and it will turn into a JSON string database. We'll never know that happens because doctrines will always make sure we are just dealing with an array here. When I give roles, say roles equals this arrow roles. Remember I said just make sure your user always has at least one role. If you have a user with zero roles, weird thing s happen. I recommend always making sure you have the role user. If not, in array, role_user, roles then pop that on there. Return. Roles. Of course, we'll also need set roles function.

Lets generate the migration for this. Command console, doctrine, migration diff, doctrines migration migrate. You can double check migration first before running it if you want to. Finally we can update our fixtures with roles. Right now we'll just give everyone the same role, role admin. Reload the fixtures. It will log us out because we just deleted the user. Now we log back in. It bounces us back to that URL and we have access because we have both roles.

