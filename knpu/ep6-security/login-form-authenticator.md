# Login Form Authenticator

When you talk about security and specifically authentication all of this is configured in appconfigsecurity.ymail.  We are going to look at this piece by piece but the most important thing to know is that these firewalls are your authentication system.  There's always only one firewall active at any time.  You see if you go to any of the URLs that start with underscore profiler or underscore WDT or CSS or images you hit the DEV firewall and this basically turns security off and that's the way for Symphony to make sure that you don't accidentally secure some debugging tools or some static assets.

In reality for every other requests we have this main firewall and our job is to activate different ways to authenticate under that firewall.  You see with the single firewall we might choose to allow the user to authenticate in many ways like via a form login or maybe via HTT basic or maybe via an API token or Facebook login.  I want your firewall setup to look like mine.  There are use cases for having an additional firewall but you probably don't need that set up.  That's most common when you have a HTML front end for your sites and  a very very different API system.  We talk about that in our Symphony rest tutorial.

Now if you look at an official documentation about building a login form you are going to notice the way they do it is they activate a key called form underscore login under their firewall and basically everything else just happens magically.  What I mean is when you hit submit on your login form Symphony intercepts the request and takes care of everything else.  It's really cool because it's really quick to set up but it's super magical and it's hard to extend to get it to work how you want.  We are not going to use the built-in form login functionality.  Instead we're going to use a system that's new in Symphony 2.8 called Guard, it's still going to be pretty easy to set up but you're going to have a lot more control over everything.

Step one, when you have a new way that you want your user to be able to authenticate, you're going to create an authenticator class.  Create a new directory called security inside of there a new class let's call it login form authenticator.  The only rule about authenticator is it needs to extend an abstract guard authenticator but if you have a login form authenticator there is another classic that can help you called abstract form login authenticator.  It just makes your life a little easier.  Hit command end, go to implement methods and I'll select the first three then I'm going to go back to command end and select the other two.

That just gets them in an order that I like inside this class even though that doesn't matter.  The idea of a an authenticator is that your authenticator will be called on every single request and our job in this authenticator is to look and see if the user has submitted, has hit submit on the login form and if they have to read the username, read the password and load the user.  The one quirk now notice right now the way we have our login form set up if you press login that actually makes a post request back to slash login.

In get credentials we have two jobs, first we need to see if the current requests coming to the system is one we care about.  In our case we sent the login form so that when we hit login it actually posts directly back to slash login.  We don't want to actually look for user and password if the URL is slash login and the method is post, so let's do that.  Create a new variable called is login submit and we will set that to request arrow get path info, that's the URL request, equal equal slash login and request is method post.  Both of those are true this is a login submit.  If not login submit just return null, when you return null from an authenticator authentication stops.  It doesn't mean authentication fails it just lets the requests continue, it's our way of saying hey the user is not trying to log in on this request via the login form.

The one little quirk to watch out for with form login authenticators is even though we're not handling the the form login logic instead of our login action we do need to have a route for the URL that we're submitting to.  As long as if you have a route for slash login and you handle slash login in your authenticator life is going to be fine.  We're definitely as slash login so our next job we need credentials is actually return the username and password that were submitted.

we are using a form to handle things lets use the form to get that data.  Normally on the controller we call this arrow create form to build our form.  In reality that goes out to the form factoryservice and calls create on it.  Since I have the login form authenticator we're going to need to use depends the injection to get the form factory.  I'll do command end go construct and if I just guess form factory yup looks like a form factory interface that's probably what we want.  Then I'll do option enter initialize fields to set that property up at the top for me.

If you weren't sure about that you can always go over here on bin counsel debug column container form.factory and that will tell you the exact class and that's the one you can type into.  Typing is optional but we're big kids so we're going to do it.  Down here we will do something that looks a lot like our normal controller now so this arrow form factory, arrow create will pass it login form colon colon class.  Then just like normal pretend like your in a controller from an arrow handler request and then normally we would check if the form is valid but we're not going to add any validation to our form we are going to handle all of that inside of this class itself, instead I'll just say that data equals form get data then we'll just return data.

Since our form is not bound to a class that's actually going to return the associate of array of underscore username and underscore password.  Next since we returned to something from get credentials, get users called in credentials is actually equal to this array right here.  We know that username is stored in credentials left score bracket underscore username.  Our job here is to return the user object that matches that username since ours is stored in the database we are going to need the entity manager.  I'll go back up to the construct add comma entity manager $em and once again hit option enter just as my shortcut to go and set that property.

Down below it's real simple return this arrow em arrow get repository app on the user arrow find one by and remember our field is actually called e-mail so I'm using a username filed in my form but I really could call it e-mail so we want to query by e-mail.  Easy.  If this returns null guard authentication will automatically cause it to fail so we don't need to worry about it.  But if this does return a user object then check credentials is called and this is our opportunity to check the password if we need to.

If we want to we could actually just skip this because we don't have a password yet and say return true or we can at least put in some fake logic.  First I'll say password equals credentials bracket underscore password and lets make every user have the same password right now.  Select password does not equal I like turtles then if password equals I like turtles then return true.  If you return true from check credentials authentication passes.  Otherwise we will return false and the user will see a credentials not found error.

That's it, authenticators are always these three methods, get credentials, get users and check credentials.  Finally if we fail authentication or for successful the authenticator will redirect us to the correct spot, we just need to tell it where our login form is and what URL to go to after login is successful.  For this we are going to need the router, once again I'll go back to the top and a third constructor argument for the router is going to be super cool you can use the interface but that doesn't matter.

I'll hit option enter to initialize that field and then down below I'll return the login URL which is this arrow router arrow generate security underscore login.  Before I get default success redirect URL return this arrow router arrow generate and we will send them to the homepage.  The cool thing about this is this doesn't mean that the users always redirect the homepage the authenticator is smart enough to redirect them to the previous page they were trying to visit before they were forced to login.  But if they did go directly to the login form then we will send them to the homepage.  That is it.

The last steps here is that we need to register as a service so do app.security.loginformauthenticator class login form authenticator and because I am supper lazy I am going to auto wire that.  Next copy that class name and then go into to security.ymail and we're going to activate that authenticator.  To do that go under your firewall and say guard below that say authenticators and below that do a dash and then do the service name, as soon as you do that check get credentials will be called in every single request in our form system should start working it's magic.

It's a bit of set up but we are in really great shape right now.  Let's try it.  First I'll type in weaverryan+1@gmail.com that is is one of our valid users but I'll just type foo so wrong password.  Beautiful.  Now let's try doing it with the right password, I like turtles.  Check this out, it did redirect the homepage but we have a nasty error, but even though it doesn't look like it authentication totally just worked.  The problem is that when we were redirected after login it had trouble storing our user in this session.

Let me prove it to you.  Open up config underscore dev.ymail and set intercept redirects to true.  This is a cool little feature in Symphony where instead of actually redirecting you whenever you hit a redirect it will stop you and show you the web debug tool bar for that page.  Now if I go to slash login again, login in with weaverryan, I like turtles, hit enter watch this.  We're still in slash login it didn't redirect yet look at this, we are logged in at weaverryan+1@gmail.com.  So authentication works but it's having some problems storing our user in this session.  That's going to be a really easy thing to fix.

