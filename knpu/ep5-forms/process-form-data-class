# Process Form Data Class

By default, a Symfony form is actually gonna have no action equals in the form tab, which means that it’s going to submit right back to the same route and controller. And you can do something different, but that’s typically how we handle our form submits. A single controller renders the form and processes the form. So, a new action if the request method is post, let’s actually process the form and get this data back. So, first, we’re going to of course need the request object, because that’s where all of the request information, including post data, is stored. Now, to actually submit the form and get the data out, you’re gonna call a method called form arrow, handle request, and pass the request object.

This is really cool because the form knows what fields it has on it. So form handle request goes out and grabs the post data off of the request object for those specific fields, and then processes them. Now a confusing thing here is that thing only handles data on post requests. So if this is a get request, this method does nothing, and our form renders just like it did before. Now of course, you can configure the form to handle data on a get request also, which you might do for a search form. And if you need that, google the docs for it. It’s just a small bit of configuration. 

After handle request, if the form has been submitted, then we’re gonna wanna do something with that information, like save a new genus. So add an if statement for if form arrow is submitted, in other words if it is a post request, and form arrow is valid, in other words, did the form pass validation rules. We haven’t added any validation yet, but we will soon. If we get into this if statement, then we know life is good. We’re gonna save some data. So let’s just dump form arrow get data. That’s how you get your data off of the form. I’m gonna see what that is. So go back. Let’s fill in our form with some very realistic data, and submit. And check that out. Here’s the dump. It gives us back an associative array with the three fields we added our form. 

So and it’s as simple as the form is super-duper simple. You add three fields here. You render them in your template. And then when you get your submitted form, that gives you back an associative array. And that would be very, very easy to use that associative array to create a new genus object, and just populate that data piece by piece, and then save that via doctrine. But, it would be even cooler if we could have the form framework take this data and create the genus object automatically for us.

That would save us some time, and we can do exactly that. In genus form type, go down to this configure options method, and add resolver arrow, set defaults. Pass that in an array with a single key called data class set to at bundle slash entity slash genus. The class name for our genus object. This tells the form not to give us back an associative array, but to give us back a genus object. If we go back now and refresh, boom!  There is a brand-new genus object that’s just waiting to be saved. 

The way this works is via the getter and setters, because remember all these properties are private. So at first, when we got back an associative array, these field names – name, species, count, and fun fact – could have been anything. But as soon as you bind your form to a class, the name, species, count, and fun fact need to correspond to properties inside of your class. And actually that’s not entirely true, because the for type works via getters and setters. So in reality, when you have a name field, it requires you to have a get name and a set name method. It doesn’t actually have a name property, but usually you will. So the point is that the form framework works via getters and setters. When you submit the form, it takes the name value and calls set name on your object.

So if you go back and just highlight the URL and hit enter, this will make a get request back to your form. And this skips the form processing and just renders our form like normal. So now that we have this form bound to an entity, let’s add a couple more fields, like subfamily – we’re even getting autocomplete now – and is published, which should probably be a checkbox – and first discovered at, which will have to be some sort of a smart date field. Cool. Try that out. Refresh, and a huge error!

Catchable fatal error, object of class subfamily could not be converted to string. Okay. That  is weird. Here’s what’s going on. So far all of our fields have been text fields, but there’s a lot more coolness going on behind that. In fact, what the form framework is doing is it’s looking at each of these properties on genus, and it’s guessing what field type to make that. When it sees species count, it sees that this is a relationship over to another entity, so it actually tries to create a dropdown of subfamilies, which is awesome because that’s exactly what we want.

We’re gonna talk more later about customizing all of these different field types. But in order for that dropdown to work, it needs to be able to turn each subfamily object into a string so that it has some text it can put in the dropdown. And for that to work, we need to add a public function underscore underscore two string method to our subfamily class. So now go back and refresh, and it looks awesome. Look at this. Automatic free dropdown without doing any work. It notices that is published should be a checkbox because that’s a Boolean field, and it also knows that first discovered at’s a date field, so it put three text boxes for the date. Now, the select boxes are ugly, so we’re gonna fix that later. But it’s cool that it actually guessed the right type.

So let’s pull our form back in and what – oh, okay. One more error. Neither the property is published nor one of the methods get is published exists. So remember that the form framework needs every field to have a getter or a setter. In our case, this is published – if you look on my genus. This is my fault when I set this up. I have an is published property, and I have a set is published, but I do not have a get is published. If you wanna work with the form framework, you’re gonna need to have the getter for that field as well. So I’ll just get is published, and now it is happy. It dumps our genus object, and check out the subfamily field. It even pre-populated the subfamily field with a subfamily object. It queried the database and found the one that I selected. So we’re ready to go. Let’s save this guy.
