# Dependency Injection

So we need the markdown transformer to do things; parse the markdown and eventually cache it.  Let’s start with the first one.  Go to your genus controller code and let’s just copy the code here that originally transformed our text into markdown. And we’ll just paste that into parse, return that, and update the variable to str.  All right?  Great.  Let’s go back.  Refresh.  And it explodes.  Okay, attempted to call an undefined method named “get” on our markdown transformer class.  So forget about Symfony.  That makes sense.  This class which we just created doesn’t have a get function and it doesn’t extend anything.  This function doesn’t exist.  
But more importantly, that get function does exist in our controller.  But more importantly, the controller has access to the container via this->container.  And after that, you can say ->get to fetch any service that you want.  That’s special to the controller.  Only the controller has this magical access to this ->container.  Or you can shorter that to just this ->get.  But as soon as you’re outside of the controller, like our new markdown transformer service, you don’t have access to the container.  In fact, you don’t have access to anything.  Inside of parse function, literally the only variable that you have access to is the str{
So the question is when you’re not in the controller how do you get access to the container?  But let me ask a different question.  We don’t really need the container inside of this parse function.  What we really need is the markdown parser object.  So the question really is how do we get access to the markdown parser object from inside of our markdown transformer?  And the answer to that is dependency injection; the scariest term ever of the simplest idea.  Seriously, I think we invented that word just to scare off developers that aren’t brave enough to continue past this.
I’m gonna show you what dependency injection is.  And you’re gonna be completely underwhelmed by how simple it is.  So here’s how it goes; whenever you’re inside of a class and you need access to an object that you don’t have, like markdown parser, add a public function__construct and add that as an argument.  Next create a private property.  And then in the construct function just set that.  This->markdownParser=markdownParser.  And then down in the parse function, instead of this->getmarkdownparser just reference that property.
If our entire universe is the markdown transformer class, we don’t know or care who is going to instantiate this object.  But whomever instantiates these objects is forced to pass in a markdown parser and we store it on a property.  And then later when somebody calls the parse function, we have access to that object.  This is sometimes called inversion of control because basically we’re forcing whoever uses this object to have to worry about passing us the markdown parser.  And in fact that’s the problem here now.
In genus controller you’ll see that this is being highlighted as required parameter markdown parser is missing.  So it’s not our responsibility to pass the argument there.  We know how to get the markdown parser and self-controller; this->getmarkdown.parser.  And it should be that simple.  So go back, refresh, and it works.  Now twig is escaping the ptag, and we’ll fix that in a second.  But for now this is kind of convenient because we can see that the markdown is being parsed into html.  
Now whenever you do have a construct function with an argument like this, it’s a good idea to type hint that argument with whatever instance that variable is.  And if nothing else, that’s helpful because it will help you or other developers know what markdown parser is.  Because right now I can’t tell exactly what object it is and I don’t know what methods I can call on that object.
So go do bin/console debug container and search for markdown.  And then select markdown.parser.  And you can see that the markdown.parser is actually an instance of this Knp/markdownBundle Max class.  So most logically you might think that we would type in this with that max object.  But hold on a second.  I’m actually gonna do shift shift and type max in.  And I’m gonna open up that class.  And you’ll see this class Max extends markdown parser.  I have a feeling that the max class is maybe not the best class to type hint with.  
This markdown parser is actually the one that does all of the work.  So if I were to type in this, I would probably either type it with markdown parser or you can also see that this implements a markdown parser interface.  And a lot of times if you find an interface that something implements it’s a good idea to type hint the interface.  In theory that can help you later because you can actually change to a new instance.  But it doesn’t really matter all that much.  But to be good developers, let’s hit this with markdown parser interface.  Now it’s very clear what methods we call on that.
Well, hold on a second, I kind of thought this warning of transform would go away when I type hinted that.  But now it says method transform is not found on the markdown parser interface.  So if we open that – ah, an interface actually says we only have one method on it called transform markdown.  
Now, by the way, this will work right now.  If I refresh, this isn’t breaking anything.  It’s just that we are forcing whomever uses this class that has any markdown parser interface and then we’re calling a method that’s not on that interface.  So, technically somebody could pass as something else that doesn’t have that method on it.  So let’s just change that to transform markdown.  And if you look they actually do the same thing.  The transform markdown object just calls transforms.  The transform and transform markdown are synonyms in this library.  But technically the interface says transform markdown so we’re gonna type in with that.
So the moral of the story is when you need an object inside of a class use dependency injection at a construct function and type hint it with either a class or an interface.  It doesn’t matter.  And now we are in good shape.
