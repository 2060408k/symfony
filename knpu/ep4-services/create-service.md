# Create Service

Hey, hey, friends!  Welcome back to the next tutorial about Symfony.  And this is a really important one because we’ve talked a lot about using services.  But we’re gonna take the next big step here and this is really going to unlock and open up everything else that you’re going to do.  Now as always, you should totally code along with me.  You will get much more out of it.  To do that, go to the individual screen cast page.  Go to download.  Download the code, unzip it, and move into the start directory.  I already have a start directory code here.  So I’m just going to open up a new terminal tab and run php bin/console server:run.  If you just downloaded it, open up the read me file.  There are a few more instructions for installing composer and setting up your database.  
From previous episodes we already found out that Symfony doesn’t really do anything.  Everything is done by one of the many services that live inside of Symfony’s container.  For example, the render function that we’re using inside our controller to render template the help command that open that, you can see what this is really doing is going out to get a service in the container called templating.  So Symfony doesn’t render templates.  The templating service actually renders templates.  And we get a big list of all the services by running bin/console debug:container.  And these are all of the tools that we have at our fingertips right out of the box of Symfony.
We also found out that you can control these services act config, config.yml file.  For example, the templating service and really twig, which works behind it, can be controlled under the twig key.  So we use the number_format: thousands_separator: to configure how the number on a score format works with large numbers.  Does it use a comma or a period when you print out numbers like 1,000?  
Now we have a new goal.  And the question is can we add our own services to this container?  Absolutely.  And doing so is the last big piece towards really getting hold of all of the most important concepts in Symfony.
So here’s the problem right now.  If you look in show action, remember we used to have about 15 lines of code that parsed our fun fact through markdown and then cached it.  I want to add this back.  But I don’t want to have these 15 lines of code in my controller.  Why?  Well, three reasons.  One is I can’t reuse this.  So if I want to do some markdown parsing somewhere else, I would have to copy and paste all these 15 lines of code.  Second, it’s not very clear what these 15 lines of code do because it’s just 15 lines of code.  I have to actually scan through and see what these do in order to figure out that their parsing markdown and caching it.  And, three, if you want to unit test this it’s not possible.  To unit test something it has to live somewhere else.  
So whenever you have a big chunk of code that does one job, instead of leaving it in your controller, you should isolate it to outside class.  And when you do that, as you’ll see, you’ll be able to reuse it.  It will be clear what that code does.  And eventually you’ll be able to unit test it.  

So here’s how we do it:  Whenever you want to isolate some code you’re gonna start by creating a new PHP class.  In app I’ll create a new directory called service.  The name of that is not important at all.  And inside of there, I’ll spread a new PHP class called MarkdownTransformer and start it off with a simple public function_parse with a $(str) {.  And just to keep things simple for now, let’s return str to upper of that string.  Eventually this will hold all of our code for transforming the markdown and taking care of the caching.  So pretend for now like it’s doing a lot more than this silly one line that it’s doing.  
So now that I’ve isolated our code externally we’ll want to use this inside our genus controller.  So to do that, for now, because eventually I’m gonna show you a way cooler way of doing this, just create a new $transformer = new MarkdownTranformer.  And then we can say funFact = Transformer->parse.  And we’ll pass it genus->getFunFact.  And that’s it.  So if you have an outside class and want to use it to substantiate it and call a method on it.
And finally let’s pass that funFact into our template so that we can render the parse diversion of it.  And I’ll hold command and click into the template.  And I’ll change the echo from genus.funFactor just funFact and that’s it.  So how did that go over?  We have our built in webserver running.  So we’ll go to localhost colnate1000/genus.  Click a genus and there it is; FUNFACT in all upper case.  
So believe it or not, you just saw one of the most important object oriented strategies that there is.  And that is take big chunks of code and isolate them to an outside function in an outside class.  This markdown transformer is a service because remember a service is just a class that does something.  And by isolating code into a service you start down what’s called a service oriented architecture where instead of having all your code in your controllers you start to organize them into nice little services that each do just one job.  
Now a markdown transformer is not really doing any of the work yet.  So that’s what’s next.
