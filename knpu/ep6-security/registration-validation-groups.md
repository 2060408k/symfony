# Registration Validation Groups

Registration is working nice but it is missing validations. Let's start adding that. Since our form is bound to our user class, that is where our annotation rules are going to go. First, whenever you use annotations you need to have a use statement for it. Earlier we added validation to our genus class. You can either copy this use statement right here, grab it from the documentation, or you can do what I do and cheat, which is by saying "use" and then an annotation you know exists, like not blank, then delete the last part and say, "as [assert 00:00:40]" We obviously want email to be not blank. We also want email to be a valid email address. In [plain 00:00:54] password, we also need that to be not blank. Pretty simple.

Let's go back, fill this out blank and there are our validation errors. This is looking good. Except, check this out. Let's type [inaudible 00:01:12]plus1@gmail.com. That email address is already taken. I should not be able to register with that user. Check that out, no validation rules preventing that so that would go into the system. Because the email address is unique in the database it would actually cause an exception to be thrown, which is no bueno.

How can we add a validation rule to prevent that? Fortunately there's a very special validation rule called unique entity which does exactly that. It is a rare validation rule that actually goes right on top of your class. You start by saying unique entity. Notice this lives in a different spot than the other annotations, so it actually gets it's own use statement. Then you just need to configure it. Like always, you can go to the reference section of documentation to figure out what can pass as unique entity, or also remember, if you hold command you can click into it and all of these public properties are the options that you can pass to your annotation.

The ones we're going to need to pass are fields, which tell it which field you need to be unique in the database. Then we're also going to customize the message. We say, "Fields = email," and that means that the email field needs to be unique. This says fields because technically you could create a unique validation across multiple fields. Then we'll say, "Message = looks like you already have an account." Easy enough. Let's go back, hit register again. There it is.

We're good, right? Well, almost. There's one last gotcha with validation with registration. It's this: right now we need [plain 00:03:07] password to be required. Later when we create an edit profile form for the user, in that case if they don't want to change their password they may leave [plain 00:03:24] password blank, and that's okay. Unfortunately because of this assert here when you work with that form it's going to assert that password is not blank and it's going to cause a validation error. We need this annotation to only work on the registration form.

Here's how you do it. Take advantage of something called validation groups. Do this, do the "Not blank at groups =," then in double quotes say, "registration." That is a string that I just invented. There's no significance to that. Go back, hit register, and check that out. The error goes away. Here's what's happening. By default when you add a constraint it goes into a group called defaults. Then when your form is validated it validates all constraints in the default group. Now that we've put this into a different group called registration, when a form validates it doesn't validate using that constraint.

What we want to do with the registration form is we want to actually validate everything in the default group and everything in the registration group. To do that you're going to go into your form and you're going to add another option and set defaults called validation groups. You're just going to set that to an array with Defaults with an upper case D and then registration. That takes care of things. The last thing I want to do is automatically authenticate the user when they register, because that's really what our users want.

