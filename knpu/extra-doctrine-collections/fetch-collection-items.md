# Fetch Collection Items

So thanks to our coding here, we know that we can add a user to the genus scientists array and just save. It takes care of inserting and eventually removing the records from that join table. Now how can we actually get that information? Specifically, what I want to do is on the genus page, down here, I want to list all of the users that have studied this genus. What we want doctrine to do is query that join table and give us an array of the user objects that are in the join table for this genus. It turns out that just happens automatically. All we need to do in genus is expose a setter. Public function, get genus scientists and return this arrow genus scientists, and that's it. You see, doctrine's going to automatically query that join table and populate this property for us. We don't need to worry about doing any of that.

That means that in the show page for genus, we can go straight down here and start printing out scientists. I can do a header called lead scientist, and it'll make a list group and start mooping over those scientists. What I mean is for genusScientists in genus.genusScientists in for. Now I call this genus scientists, but we know that that is going to be a user object. In fact, in genus I'm going to add some petri documentation above the function that says that yes this does technically return an array collection, but it also really returns an array of user objects. By using that syntax petri storm will give us auto-completion on the array collection object, or if we loop over the items that come back from this method, petri storm will know that those are actually user objects. Since out of our each, we can say LI. Class list of each group items. Then let's make a link to the user show page. It's not something we've created in any of these tutorials, but there actually is a page that gives you user information. It's inside your user controller, and the route is user_show and it takes the ID of the user.

That's what we're going to link so the curly curly path pace user show. Then we'll pass ID genus scientists back ID, because remember that is a user object. And probably down here, we'll print out genusScientists..full name. Why full name? If you look in the user class, I added a method called get full name which [inaudible 00:03:51] it's first name and last name. [inaudible 00:03:53] called genusScientists.full name. That's it. Doctrine's going to take care of all the work for us. If we refresh the page, this genus is empty, because we haven't updated our fixtures yet. Let's go back to genus/new and that will create us a new genus with a link scientists, and there it is. Reading data is very simple. Now if you click this, you'll go to the user show page. What if we want to do the same thing here? What if I want to make a list on the right side of all the genuses that this user has studied? All the genuses link to this user.

Every time you talk about a relationship, any relationship, a many-to-one, or in many-to-many, you can always look at a relationship in two different directions. For example, I'm in early tutorial. We worked on the genus note entity, which is a many-to-one relationship to genus. If you look in genus, you'll notice that we mapped the other side of this relationship, one-to-many. Now in the database, you can always look at a relationship in two different directions. Either we can look at the genus and ask, Give me all the users that are related to this genus. It's also equally valuable to talk about a user and ask, Give me all the genuses related to this user. Now in doctrine, even though there's always two sides of the relationship, one side is always known as the owning side, and the other side is known as the inverse side. We're going to talk more about why that's important in a little while, but the owning side is going to be the only side that we can update. Where as the inverse side is just there for the convenience of reading.

We actually saw this earlier with the genus note in an earlier tutorial. In here we have a many-to-one over to the genus entity. This is the owning side of the relationship. Then I'll click the notes here by holding command. That just takes me to the genus entity. This was us mapping the inverse side. We did this just for the convenience of being able to start with a genus object and ask for all the notes for that genus. Now when we talk about a many-to-many relationship, you actually can choose which side is the owning side and which side is the inverse side. In a few minutes, I'll talk to you about why you might choose one or the other. In this case, the owning side is the side that we first added the many-to-many on. The owning side is also the only side that can have the join table on it. If we want to map the other side of this relationship, all we need to do is go into user and [inaudible 00:07:33] private property called studied genuses.

This will also be a many-to-many relation with target entities set to genus, but this time we're going to say, Map by equals genusScientists. That refers to the property inside of the genus, and now over in genus, we're actually going to add inverse by studied genuses, which points to the property inside of user that this relates to. When we only had one many-to-many, doctrine knew that the many-to-many on the genus was the owning side. Soon as you have two, you identify which is the owning side by adding the map by verses the inverse by. Back in user, remember every time that you have a relationship that is a collection, like this is a collection of studied genuses, you need to add construct function and initialize that to a new array collection. Now in order to access these studied genuses, I'm going to go down to the bottom and make a new public function called get studied genuses, and we'll return that property. I'll put some petri documents that says, This is an array collection, but it's also really an array of genus objects. Perfect.

What this allows us to do is go into the show template for the user which is the page that we're looking at right now. We can very easily print out all of the genuses that this user's studying. I need class for a container. Go a little header that says, Genus studied. We'll just make another list group down here. This time look for genus study in user.genuses get studied genuses. The inside will look a lot like our other template. We'll add our LI, and then we'll add a anchor tag. We'll send this back to the genus show page, which we now know accepts the slug of the genus. We can pass slug:genusstudy.slug. Then we'll print out genusstudy.name. Let's see if it works. Refresh and there is our list of the three genuses that this user's studying. We have that join table in the middle, but doctrine's doing all of the work to go and fetch those users for us. In fact, if you click down on the web profile, you can see what that query looks like. There's a slug from genus but it inter-joins over to genus scientists and says, Where genus scientists.user ID equals 11, which is this user. All happening behind the scenes.

Now when you have collections like this, the order of these is sort of random. It's just whatever order that the user, the database is sending those back to us. If you want to, you can control that a little bit. You can change its order by. In fact, you can do this on any relationship that is an array, meaning a many-to-many or a one-to-many. You can add @rm/orderbycurlybrace and then name equals ascending. As soon as we refresh, that switches to be in alphabetical order. If you couldn't see the difference, you can click into the web depot tool bar, and you can see that same query now in order by [inaudible 00:12:08] that name ascending. Now we can fetch the relationship by both sides of the relationship. Next, let's see how we can remove a genus from a user.
